--- CaseMotionMatching.cpp.orig+++ CaseMotionMatching.cpp@@ -76,10 +76,36 @@         }
 
         glm::mat3 RotationFromTo(glm::vec3 from, glm::vec3 to) {
-            from = glm::normalize(from);
-            to = glm::normalize(to);
-            if (glm::length2(from) < 1e-8f || glm::length2(to) < 1e-8f) return glm::mat3(1.f);
-            glm::quat q = glm::rotation(from, to);
+            // NOTE: glm::rotation / glm::length2 live in GLM *gtx* headers in some versions.
+            // To keep the lab compiling with the packaged GLM, we implement the minimal
+            // "rotation from A to B" here without relying on those helpers.
+            const float fromLen2 = glm::dot(from, from);
+            const float toLen2   = glm::dot(to, to);
+            if (fromLen2 < 1e-8f || toLen2 < 1e-8f) return glm::mat3(1.f);
+
+            from *= 1.0f / std::sqrt(fromLen2);
+            to   *= 1.0f / std::sqrt(toLen2);
+
+            const float c = glm::clamp(glm::dot(from, to), -1.0f, 1.0f);
+
+            // Same direction
+            if (c > 1.0f - 1e-6f) return glm::mat3(1.f);
+
+            // Opposite direction: pick an arbitrary orthogonal axis
+            if (c < -1.0f + 1e-6f) {
+                glm::vec3 axis = glm::cross(from, glm::vec3(1.f, 0.f, 0.f));
+                if (glm::dot(axis, axis) < 1e-6f) axis = glm::cross(from, glm::vec3(0.f, 1.f, 0.f));
+                axis = glm::normalize(axis);
+                return glm::mat3_cast(glm::angleAxis(glm::pi<float>(), axis));
+            }
+
+            glm::vec3 axis = glm::cross(from, to);
+            const float axisLen2 = glm::dot(axis, axis);
+            if (axisLen2 < 1e-10f) return glm::mat3(1.f);
+            axis *= 1.0f / std::sqrt(axisLen2);
+
+            const float angle = std::acos(c);
+            const glm::quat q = glm::angleAxis(angle, axis);
             return glm::mat3_cast(q);
         }
     }
@@ -444,7 +470,7 @@                 glm::vec3 p = _desiredFuturePosWorld[i];
                 glm::vec3 fwd = _desiredFutureFwdWorld[i];
                 fwd.y = 0.f;
-                if (glm::length2(fwd) < 1e-6f) fwd = {0.f,0.f,1.f};
+                if (glm::dot(fwd, fwd) < 1e-6f) fwd = {0.f,0.f,1.f};
                 fwd = glm::normalize(fwd);
                 traj.push_back(p);
                 traj.push_back(p + fwd * 0.25f);
